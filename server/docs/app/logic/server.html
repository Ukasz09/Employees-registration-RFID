<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>app.logic.server API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.logic.server</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from app.database_connection.local_database import LocalDatabase
from app.logic.terminal import Terminal
from app.logic.worker import Worker
from app.logic.registry_log import RegistryLog
from datetime import datetime

terminal_json = &#34;data/terminals.json&#34;
workers_json = &#34;data/workers.json&#34;
logs_json = &#34;data/registrations.json&#34;


class DataInputError(BaseException):
    def __init__(self, message):
        self.message = message


class Server:
    def __init__(self):
        self.__database = LocalDatabase(terminal_json, workers_json, logs_json)
        self.__terminals_dict = self.__database.read_terminals()
        self.__workers_dict = self.__database.read_workers()
        self.__logs_dict = self.__database.read_logs()

    def add_terminal(self, term_guid, term_name):
        &#34;&#34;&#34;
        Add terminal and save it in database
        :param term_guid: GUID of new terminal
        :param term_name: Name assigned to new terminal
        &#34;&#34;&#34;
        if term_guid not in self.__terminals_dict:
            new_term = Terminal(term_guid, term_name)
            self.__terminals_dict[term_guid] = new_term
            self.__database.write_terminals(self.__terminals_dict.values())
        else:
            raise DataInputError(&#34;Terminal with GUID: &#34; + term_guid + &#34; already exist&#34;)

    def remove_terminal(self, term_guid):
        &#34;&#34;&#34;
        Remove terminal from database
        :param term_guid:  GUID of terminal to remove
        &#34;&#34;&#34;
        if term_guid in self.__terminals_dict:
            del self.__terminals_dict[term_guid]
            self.__database.write_terminals(self.__terminals_dict.values())
        else:
            raise DataInputError(&#34;Terminal with GUID: &#34; + term_guid + &#34; not exist&#34;)

    def add_worker(self, name, surname, worker_guid):
        &#34;&#34;&#34;
        Add/register new worker in system and save it database
        :param name: Name of new worker
        :param surname: Surname of new worker
        :param worker_guid: GUID of new worker
        &#34;&#34;&#34;
        new_worker = Worker(name, surname, worker_guid)
        if worker_guid not in self.__workers_dict:
            self.__workers_dict[worker_guid] = new_worker
            self.__database.write_workers(self.__workers_dict.values())
        else:
            raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; already exist in database&#34;)

    def remove_worker(self, worker_guid):
        &#34;&#34;&#34;
        Remove worker from database
        :param worker_guid: GUID of worker to remove
        &#34;&#34;&#34;
        if worker_guid in self.__workers_dict:
            del self.__workers_dict[worker_guid]
            self.__database.write_workers(self.__workers_dict.values())
        else:
            raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; not exist&#34;)

    def assign_card_to_worker(self, card_guid, worker_guid):
        &#34;&#34;&#34;
        Assign RFID card to worker
        :param card_guid: GUID of RFID card to assign
        :param worker_guid: GUID of worker to whose card will be assigned
        &#34;&#34;&#34;
        if worker_guid in self.__workers_dict:
            card_owner = self.get_card_owner(card_guid)
            if card_owner is not None:
                raise DataInputError(
                    &#34;Card with GUID: &#34; + card_guid + &#34; already assigned to worker with GUID: &#34; + card_owner.worker_id)
            self.__workers_dict[worker_guid].cards.append(card_guid)
            self.__database.write_workers(self.__workers_dict.values())
        else:
            raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; not exist&#34;)

    def get_card_owner(self, card_guid):
        &#34;&#34;&#34;
        Return object of worker to whose belong card or None if to no one in database
        :param card_guid: GUID of RFID card
        :return: &lt;Worker&gt; instance or None
        &#34;&#34;&#34;
        for w in self.__workers_dict.values():
            if card_guid in w.cards:
                return w
        return None

    def unassign_card_from_worker(self, card_guid):
        &#34;&#34;&#34;
        Unassign card which had assigned to worker
        :param card_guid: GUID of RFID card which needs to be unassigned
        &#34;&#34;&#34;
        for w in self.__workers_dict.values():
            if card_guid in w.cards:
                w.cards.remove(card_guid)
                self.__database.write_workers(self.__workers_dict.values())
                return w.worker_guid
        raise DataInputError(&#34;Card with id: &#34; + card_guid + &#34; hasn&#39;t been signed to any worker&#34;)

    def register_card_usage(self, card_guid, term_guid):
        &#34;&#34;&#34;
        Register usage of RFID card in system via writing usage log into database
        :param card_guid: GUID of used RFID card
        :param term_guid: GUID of used terminal
        :return: Card owner GUID or None if card without assigned owner
        &#34;&#34;&#34;
        card_owner = self.get_card_owner(card_guid)
        if not self.terminal_in_database(term_guid):
            raise DataInputError(&#34;Terminal with id: &#34; + term_guid + &#34; not assigned in database&#34;)
        if card_owner is None:
            owner_guid = None
        else:
            owner_guid = card_owner.worker_guid
        self.register_log(card_guid, term_guid, owner_guid)
        return card_owner

    def terminal_in_database(self, term_guid):
        &#34;&#34;&#34;
        Check if terminal with given GUID is saved in database
        :param term_guid: GUID of checked terminal
        :return: True - is in database, False - otherwise
        &#34;&#34;&#34;
        return term_guid in self.__terminals_dict

    def register_log(self, card_guid, term_guid, worker_guid):
        &#34;&#34;&#34;
        Save new register log in database
        :param card_guid: GUID of used RFID card
        :param term_guid: GUID of used terminal
        :param worker_guid: GUID of worker to whose belong card
        &#34;&#34;&#34;
        time = datetime.now()
        self.__logs_dict[time.__str__()] = RegistryLog(time.__str__(), term_guid, card_guid, worker_guid)
        self.__database.write_logs(self.__logs_dict.values())

    def is_any_terminal_registered(self):
        &#34;&#34;&#34;
        Check if in database is registered any terminal
        :return: True - at least one terminal registerd in database, False - otherwise
        &#34;&#34;&#34;
        return bool(self.__terminals_dict)

    def get_workers(self):
        &#34;&#34;&#34;
        :return: Workers dictionary
        &#34;&#34;&#34;
        return self.__workers_dict

    def get_registered_logs(self):
        &#34;&#34;&#34;
        :return: Registered logs in database
        &#34;&#34;&#34;
        return self.__logs_dict

    def get_terminals(self):
        &#34;&#34;&#34;
        :return: Registered terminals in database
        &#34;&#34;&#34;
        return self.__terminals_dict

    def terminal_is_engaged(self, term_GUID):
        if self.terminal_in_database(term_GUID):
            return self.__terminals_dict[term_GUID].is_engaged
        return False

    def set_terminal_engage(self, term_GUID, engaged):
        if self.terminal_in_database(term_GUID):
            self.__terminals_dict[term_GUID].is_engaged = engaged

    def report_log_from_day(self, with_saving, date=datetime.now()):
        &#34;&#34;&#34;
        Generate report with all logs added in given date
        :param with_saving: True - save report in database, False - not save report in database
        :param date: will be returned only logs with date equals &lt;date&gt;
        :return: List of &lt;RegistryLog&gt; objects
        &#34;&#34;&#34;
        predicate = lambda k: datetime.strptime(k, &#34;%Y-%m-%d %H:%M:%S.%f&#34;).date() == date.date()
        filtered_keys = list(filter(predicate, self.__logs_dict.keys()))
        filtered_logs = list(map(lambda k: self.__logs_dict[k], filtered_keys))

        if with_saving:
            report_name = &#34;Report_[LOGS]_&#34; + date.date().__str__()
            self.__database.write_reports_with_objects(filtered_logs, report_name)
        return filtered_logs

    def report_log_from_day_worker(self, worker_guid, with_saving, date=datetime.now()):
        &#34;&#34;&#34;
        Generate report with all logs added in given date which relate with worker with given GUID
        :param worker_guid: GUID of worker for whose we generate reports
        :param with_saving: True - save report in database, False - not save report in database
        :param date: will be returned only logs with date equals &lt;date&gt;
        :return: List of &lt;RegistryLog&gt; objects
        &#34;&#34;&#34;
        logs_from_day = self.report_log_from_day(False, date)
        filtered_logs = list(filter(lambda l: l.worker_guid == worker_guid, logs_from_day))

        if with_saving:
            report_name = &#34;Report_[LOGS]_[&#34; + worker_guid + &#34;]_&#34; + date.date().__str__()
            self.__database.write_reports_with_objects(filtered_logs, report_name)
        return filtered_logs

    def general_log_for_worker(self, worker_guid):
        &#34;&#34;&#34;
         Generate report with all logs which are relate with worker with given GUID
        :param worker_guid: GUID of worker for whose we generate reports
        :return: List of &lt;RegistryLog&gt; objects
        &#34;&#34;&#34;
        filtered_logs = []
        for log in self.__logs_dict.values():
            if log.worker_guid == worker_guid:
                filtered_logs.append(log)
        return filtered_logs

    def report_work_time_from_day_worker(self, worker_guid, date=datetime.now()):
        &#34;&#34;&#34;
        Generate datatime value which means how much time worker with given GUID work in given day
        :param worker_guid: GUID of worker for whose we generate reports
        :param date: will be returned only logs with date equals &lt;date&gt;
        :return: &lt;datatime&gt; value
        &#34;&#34;&#34;
        worker_log_for_day = self.report_log_from_day_worker(worker_guid, False, date)
        return self.calculate_work_time_for_worker(worker_log_for_day)

    def calculate_work_time_for_worker(self, worker_log):
        &#34;&#34;&#34;
        Generate datatime value which means how much time worker with given GUID work in general
        :param worker_log: List with reports logs, which are relate with worker for whose we searching work time for
        :return: &lt;datatime&gt; value
        &#34;&#34;&#34;
        work_cycles = []
        for i in range(0, len(worker_log) - 1, 2):
            exit_date_str = worker_log[i + 1].time
            exit_date = datetime.strptime(exit_date_str, &#34;%Y-%m-%d %H:%M:%S.%f&#34;)
            enter_date_str = worker_log[i].time
            enter_date = datetime.strptime(enter_date_str, &#34;%Y-%m-%d %H:%M:%S.%f&#34;)
            result = exit_date - enter_date
            work_cycles.append(result)
        if len(work_cycles) == 0:
            return datetime.now().time().min
        if len(work_cycles) == 1:
            return work_cycles[0]
        return sum(work_cycles[1:], work_cycles[0])

    def report_work_time_from_day(self, with_saving, date=datetime.now()):
        &#34;&#34;&#34;
        Generate report with tuples (worker GUID, work time) for given day
        :param with_saving: True - save report in database, False - not save report in database
        :param date: will be returned only results with date equals &lt;date&gt;
        :return: List of tuples (worker GUID, work time &lt;datatime&gt;)
        &#34;&#34;&#34;
        fun = lambda guid: (guid, self.report_work_time_from_day_worker(guid, date))
        work_time_list = list(map(fun, self.__workers_dict.keys()))
        only_positive_work_time = list(filter(lambda time: time[1] &gt; time[1].min, work_time_list))
        if with_saving:
            report_name = &#34;Report_[TIME]_&#34; + date.date().__str__()
            self.__database.write_reports_with_tuples(only_positive_work_time, report_name)
        return only_positive_work_time

    def general_report(self, with_saving):
        &#34;&#34;&#34;
        Generate general report with tuples (worker GUID, work time) with every saved in database logs
        :param with_saving: True - save report in database, False - not save report in database
        :return: List of tuples (worker GUID, work time &lt;datatime&gt;)
        &#34;&#34;&#34;
        work_time_list = []
        for w in self.__workers_dict.values():
            general_work_time = self.calculate_work_time_for_worker(self.general_log_for_worker(w.worker_guid))
            work_time_list.append((w.worker_guid, general_work_time))
        if with_saving:
            report_name = &#34;Report_[GENERAL]_&#34; + datetime.now().__str__()
            self.__database.write_reports_with_tuples(work_time_list, report_name)
        return work_time_list</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.logic.server.DataInputError"><code class="flex name class">
<span>class <span class="ident">DataInputError</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all exceptions</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataInputError(BaseException):
    def __init__(self, message):
        self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="app.logic.server.Server"><code class="flex name class">
<span>class <span class="ident">Server</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Server:
    def __init__(self):
        self.__database = LocalDatabase(terminal_json, workers_json, logs_json)
        self.__terminals_dict = self.__database.read_terminals()
        self.__workers_dict = self.__database.read_workers()
        self.__logs_dict = self.__database.read_logs()

    def add_terminal(self, term_guid, term_name):
        &#34;&#34;&#34;
        Add terminal and save it in database
        :param term_guid: GUID of new terminal
        :param term_name: Name assigned to new terminal
        &#34;&#34;&#34;
        if term_guid not in self.__terminals_dict:
            new_term = Terminal(term_guid, term_name)
            self.__terminals_dict[term_guid] = new_term
            self.__database.write_terminals(self.__terminals_dict.values())
        else:
            raise DataInputError(&#34;Terminal with GUID: &#34; + term_guid + &#34; already exist&#34;)

    def remove_terminal(self, term_guid):
        &#34;&#34;&#34;
        Remove terminal from database
        :param term_guid:  GUID of terminal to remove
        &#34;&#34;&#34;
        if term_guid in self.__terminals_dict:
            del self.__terminals_dict[term_guid]
            self.__database.write_terminals(self.__terminals_dict.values())
        else:
            raise DataInputError(&#34;Terminal with GUID: &#34; + term_guid + &#34; not exist&#34;)

    def add_worker(self, name, surname, worker_guid):
        &#34;&#34;&#34;
        Add/register new worker in system and save it database
        :param name: Name of new worker
        :param surname: Surname of new worker
        :param worker_guid: GUID of new worker
        &#34;&#34;&#34;
        new_worker = Worker(name, surname, worker_guid)
        if worker_guid not in self.__workers_dict:
            self.__workers_dict[worker_guid] = new_worker
            self.__database.write_workers(self.__workers_dict.values())
        else:
            raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; already exist in database&#34;)

    def remove_worker(self, worker_guid):
        &#34;&#34;&#34;
        Remove worker from database
        :param worker_guid: GUID of worker to remove
        &#34;&#34;&#34;
        if worker_guid in self.__workers_dict:
            del self.__workers_dict[worker_guid]
            self.__database.write_workers(self.__workers_dict.values())
        else:
            raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; not exist&#34;)

    def assign_card_to_worker(self, card_guid, worker_guid):
        &#34;&#34;&#34;
        Assign RFID card to worker
        :param card_guid: GUID of RFID card to assign
        :param worker_guid: GUID of worker to whose card will be assigned
        &#34;&#34;&#34;
        if worker_guid in self.__workers_dict:
            card_owner = self.get_card_owner(card_guid)
            if card_owner is not None:
                raise DataInputError(
                    &#34;Card with GUID: &#34; + card_guid + &#34; already assigned to worker with GUID: &#34; + card_owner.worker_id)
            self.__workers_dict[worker_guid].cards.append(card_guid)
            self.__database.write_workers(self.__workers_dict.values())
        else:
            raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; not exist&#34;)

    def get_card_owner(self, card_guid):
        &#34;&#34;&#34;
        Return object of worker to whose belong card or None if to no one in database
        :param card_guid: GUID of RFID card
        :return: &lt;Worker&gt; instance or None
        &#34;&#34;&#34;
        for w in self.__workers_dict.values():
            if card_guid in w.cards:
                return w
        return None

    def unassign_card_from_worker(self, card_guid):
        &#34;&#34;&#34;
        Unassign card which had assigned to worker
        :param card_guid: GUID of RFID card which needs to be unassigned
        &#34;&#34;&#34;
        for w in self.__workers_dict.values():
            if card_guid in w.cards:
                w.cards.remove(card_guid)
                self.__database.write_workers(self.__workers_dict.values())
                return w.worker_guid
        raise DataInputError(&#34;Card with id: &#34; + card_guid + &#34; hasn&#39;t been signed to any worker&#34;)

    def register_card_usage(self, card_guid, term_guid):
        &#34;&#34;&#34;
        Register usage of RFID card in system via writing usage log into database
        :param card_guid: GUID of used RFID card
        :param term_guid: GUID of used terminal
        :return: Card owner GUID or None if card without assigned owner
        &#34;&#34;&#34;
        card_owner = self.get_card_owner(card_guid)
        if not self.terminal_in_database(term_guid):
            raise DataInputError(&#34;Terminal with id: &#34; + term_guid + &#34; not assigned in database&#34;)
        if card_owner is None:
            owner_guid = None
        else:
            owner_guid = card_owner.worker_guid
        self.register_log(card_guid, term_guid, owner_guid)
        return card_owner

    def terminal_in_database(self, term_guid):
        &#34;&#34;&#34;
        Check if terminal with given GUID is saved in database
        :param term_guid: GUID of checked terminal
        :return: True - is in database, False - otherwise
        &#34;&#34;&#34;
        return term_guid in self.__terminals_dict

    def register_log(self, card_guid, term_guid, worker_guid):
        &#34;&#34;&#34;
        Save new register log in database
        :param card_guid: GUID of used RFID card
        :param term_guid: GUID of used terminal
        :param worker_guid: GUID of worker to whose belong card
        &#34;&#34;&#34;
        time = datetime.now()
        self.__logs_dict[time.__str__()] = RegistryLog(time.__str__(), term_guid, card_guid, worker_guid)
        self.__database.write_logs(self.__logs_dict.values())

    def is_any_terminal_registered(self):
        &#34;&#34;&#34;
        Check if in database is registered any terminal
        :return: True - at least one terminal registerd in database, False - otherwise
        &#34;&#34;&#34;
        return bool(self.__terminals_dict)

    def get_workers(self):
        &#34;&#34;&#34;
        :return: Workers dictionary
        &#34;&#34;&#34;
        return self.__workers_dict

    def get_registered_logs(self):
        &#34;&#34;&#34;
        :return: Registered logs in database
        &#34;&#34;&#34;
        return self.__logs_dict

    def get_terminals(self):
        &#34;&#34;&#34;
        :return: Registered terminals in database
        &#34;&#34;&#34;
        return self.__terminals_dict

    def terminal_is_engaged(self, term_GUID):
        if self.terminal_in_database(term_GUID):
            return self.__terminals_dict[term_GUID].is_engaged
        return False

    def set_terminal_engage(self, term_GUID, engaged):
        if self.terminal_in_database(term_GUID):
            self.__terminals_dict[term_GUID].is_engaged = engaged

    def report_log_from_day(self, with_saving, date=datetime.now()):
        &#34;&#34;&#34;
        Generate report with all logs added in given date
        :param with_saving: True - save report in database, False - not save report in database
        :param date: will be returned only logs with date equals &lt;date&gt;
        :return: List of &lt;RegistryLog&gt; objects
        &#34;&#34;&#34;
        predicate = lambda k: datetime.strptime(k, &#34;%Y-%m-%d %H:%M:%S.%f&#34;).date() == date.date()
        filtered_keys = list(filter(predicate, self.__logs_dict.keys()))
        filtered_logs = list(map(lambda k: self.__logs_dict[k], filtered_keys))

        if with_saving:
            report_name = &#34;Report_[LOGS]_&#34; + date.date().__str__()
            self.__database.write_reports_with_objects(filtered_logs, report_name)
        return filtered_logs

    def report_log_from_day_worker(self, worker_guid, with_saving, date=datetime.now()):
        &#34;&#34;&#34;
        Generate report with all logs added in given date which relate with worker with given GUID
        :param worker_guid: GUID of worker for whose we generate reports
        :param with_saving: True - save report in database, False - not save report in database
        :param date: will be returned only logs with date equals &lt;date&gt;
        :return: List of &lt;RegistryLog&gt; objects
        &#34;&#34;&#34;
        logs_from_day = self.report_log_from_day(False, date)
        filtered_logs = list(filter(lambda l: l.worker_guid == worker_guid, logs_from_day))

        if with_saving:
            report_name = &#34;Report_[LOGS]_[&#34; + worker_guid + &#34;]_&#34; + date.date().__str__()
            self.__database.write_reports_with_objects(filtered_logs, report_name)
        return filtered_logs

    def general_log_for_worker(self, worker_guid):
        &#34;&#34;&#34;
         Generate report with all logs which are relate with worker with given GUID
        :param worker_guid: GUID of worker for whose we generate reports
        :return: List of &lt;RegistryLog&gt; objects
        &#34;&#34;&#34;
        filtered_logs = []
        for log in self.__logs_dict.values():
            if log.worker_guid == worker_guid:
                filtered_logs.append(log)
        return filtered_logs

    def report_work_time_from_day_worker(self, worker_guid, date=datetime.now()):
        &#34;&#34;&#34;
        Generate datatime value which means how much time worker with given GUID work in given day
        :param worker_guid: GUID of worker for whose we generate reports
        :param date: will be returned only logs with date equals &lt;date&gt;
        :return: &lt;datatime&gt; value
        &#34;&#34;&#34;
        worker_log_for_day = self.report_log_from_day_worker(worker_guid, False, date)
        return self.calculate_work_time_for_worker(worker_log_for_day)

    def calculate_work_time_for_worker(self, worker_log):
        &#34;&#34;&#34;
        Generate datatime value which means how much time worker with given GUID work in general
        :param worker_log: List with reports logs, which are relate with worker for whose we searching work time for
        :return: &lt;datatime&gt; value
        &#34;&#34;&#34;
        work_cycles = []
        for i in range(0, len(worker_log) - 1, 2):
            exit_date_str = worker_log[i + 1].time
            exit_date = datetime.strptime(exit_date_str, &#34;%Y-%m-%d %H:%M:%S.%f&#34;)
            enter_date_str = worker_log[i].time
            enter_date = datetime.strptime(enter_date_str, &#34;%Y-%m-%d %H:%M:%S.%f&#34;)
            result = exit_date - enter_date
            work_cycles.append(result)
        if len(work_cycles) == 0:
            return datetime.now().time().min
        if len(work_cycles) == 1:
            return work_cycles[0]
        return sum(work_cycles[1:], work_cycles[0])

    def report_work_time_from_day(self, with_saving, date=datetime.now()):
        &#34;&#34;&#34;
        Generate report with tuples (worker GUID, work time) for given day
        :param with_saving: True - save report in database, False - not save report in database
        :param date: will be returned only results with date equals &lt;date&gt;
        :return: List of tuples (worker GUID, work time &lt;datatime&gt;)
        &#34;&#34;&#34;
        fun = lambda guid: (guid, self.report_work_time_from_day_worker(guid, date))
        work_time_list = list(map(fun, self.__workers_dict.keys()))
        only_positive_work_time = list(filter(lambda time: time[1] &gt; time[1].min, work_time_list))
        if with_saving:
            report_name = &#34;Report_[TIME]_&#34; + date.date().__str__()
            self.__database.write_reports_with_tuples(only_positive_work_time, report_name)
        return only_positive_work_time

    def general_report(self, with_saving):
        &#34;&#34;&#34;
        Generate general report with tuples (worker GUID, work time) with every saved in database logs
        :param with_saving: True - save report in database, False - not save report in database
        :return: List of tuples (worker GUID, work time &lt;datatime&gt;)
        &#34;&#34;&#34;
        work_time_list = []
        for w in self.__workers_dict.values():
            general_work_time = self.calculate_work_time_for_worker(self.general_log_for_worker(w.worker_guid))
            work_time_list.append((w.worker_guid, general_work_time))
        if with_saving:
            report_name = &#34;Report_[GENERAL]_&#34; + datetime.now().__str__()
            self.__database.write_reports_with_tuples(work_time_list, report_name)
        return work_time_list</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="app.logic.server.Server.add_terminal"><code class="name flex">
<span>def <span class="ident">add_terminal</span></span>(<span>self, term_guid, term_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Add terminal and save it in database
:param term_guid: GUID of new terminal
:param term_name: Name assigned to new terminal</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_terminal(self, term_guid, term_name):
    &#34;&#34;&#34;
    Add terminal and save it in database
    :param term_guid: GUID of new terminal
    :param term_name: Name assigned to new terminal
    &#34;&#34;&#34;
    if term_guid not in self.__terminals_dict:
        new_term = Terminal(term_guid, term_name)
        self.__terminals_dict[term_guid] = new_term
        self.__database.write_terminals(self.__terminals_dict.values())
    else:
        raise DataInputError(&#34;Terminal with GUID: &#34; + term_guid + &#34; already exist&#34;)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.add_worker"><code class="name flex">
<span>def <span class="ident">add_worker</span></span>(<span>self, name, surname, worker_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Add/register new worker in system and save it database
:param name: Name of new worker
:param surname: Surname of new worker
:param worker_guid: GUID of new worker</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_worker(self, name, surname, worker_guid):
    &#34;&#34;&#34;
    Add/register new worker in system and save it database
    :param name: Name of new worker
    :param surname: Surname of new worker
    :param worker_guid: GUID of new worker
    &#34;&#34;&#34;
    new_worker = Worker(name, surname, worker_guid)
    if worker_guid not in self.__workers_dict:
        self.__workers_dict[worker_guid] = new_worker
        self.__database.write_workers(self.__workers_dict.values())
    else:
        raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; already exist in database&#34;)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.assign_card_to_worker"><code class="name flex">
<span>def <span class="ident">assign_card_to_worker</span></span>(<span>self, card_guid, worker_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Assign RFID card to worker
:param card_guid: GUID of RFID card to assign
:param worker_guid: GUID of worker to whose card will be assigned</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_card_to_worker(self, card_guid, worker_guid):
    &#34;&#34;&#34;
    Assign RFID card to worker
    :param card_guid: GUID of RFID card to assign
    :param worker_guid: GUID of worker to whose card will be assigned
    &#34;&#34;&#34;
    if worker_guid in self.__workers_dict:
        card_owner = self.get_card_owner(card_guid)
        if card_owner is not None:
            raise DataInputError(
                &#34;Card with GUID: &#34; + card_guid + &#34; already assigned to worker with GUID: &#34; + card_owner.worker_id)
        self.__workers_dict[worker_guid].cards.append(card_guid)
        self.__database.write_workers(self.__workers_dict.values())
    else:
        raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; not exist&#34;)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.calculate_work_time_for_worker"><code class="name flex">
<span>def <span class="ident">calculate_work_time_for_worker</span></span>(<span>self, worker_log)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate datatime value which means how much time worker with given GUID work in general
:param worker_log: List with reports logs, which are relate with worker for whose we searching work time for
:return: <datatime> value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_work_time_for_worker(self, worker_log):
    &#34;&#34;&#34;
    Generate datatime value which means how much time worker with given GUID work in general
    :param worker_log: List with reports logs, which are relate with worker for whose we searching work time for
    :return: &lt;datatime&gt; value
    &#34;&#34;&#34;
    work_cycles = []
    for i in range(0, len(worker_log) - 1, 2):
        exit_date_str = worker_log[i + 1].time
        exit_date = datetime.strptime(exit_date_str, &#34;%Y-%m-%d %H:%M:%S.%f&#34;)
        enter_date_str = worker_log[i].time
        enter_date = datetime.strptime(enter_date_str, &#34;%Y-%m-%d %H:%M:%S.%f&#34;)
        result = exit_date - enter_date
        work_cycles.append(result)
    if len(work_cycles) == 0:
        return datetime.now().time().min
    if len(work_cycles) == 1:
        return work_cycles[0]
    return sum(work_cycles[1:], work_cycles[0])</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.general_log_for_worker"><code class="name flex">
<span>def <span class="ident">general_log_for_worker</span></span>(<span>self, worker_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate report with all logs which are relate with worker with given GUID
:param worker_guid: GUID of worker for whose we generate reports
:return: List of <RegistryLog> objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def general_log_for_worker(self, worker_guid):
    &#34;&#34;&#34;
     Generate report with all logs which are relate with worker with given GUID
    :param worker_guid: GUID of worker for whose we generate reports
    :return: List of &lt;RegistryLog&gt; objects
    &#34;&#34;&#34;
    filtered_logs = []
    for log in self.__logs_dict.values():
        if log.worker_guid == worker_guid:
            filtered_logs.append(log)
    return filtered_logs</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.general_report"><code class="name flex">
<span>def <span class="ident">general_report</span></span>(<span>self, with_saving)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate general report with tuples (worker GUID, work time) with every saved in database logs
:param with_saving: True - save report in database, False - not save report in database
:return: List of tuples (worker GUID, work time <datatime>)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def general_report(self, with_saving):
    &#34;&#34;&#34;
    Generate general report with tuples (worker GUID, work time) with every saved in database logs
    :param with_saving: True - save report in database, False - not save report in database
    :return: List of tuples (worker GUID, work time &lt;datatime&gt;)
    &#34;&#34;&#34;
    work_time_list = []
    for w in self.__workers_dict.values():
        general_work_time = self.calculate_work_time_for_worker(self.general_log_for_worker(w.worker_guid))
        work_time_list.append((w.worker_guid, general_work_time))
    if with_saving:
        report_name = &#34;Report_[GENERAL]_&#34; + datetime.now().__str__()
        self.__database.write_reports_with_tuples(work_time_list, report_name)
    return work_time_list</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.get_card_owner"><code class="name flex">
<span>def <span class="ident">get_card_owner</span></span>(<span>self, card_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Return object of worker to whose belong card or None if to no one in database
:param card_guid: GUID of RFID card
:return: <Worker> instance or None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_card_owner(self, card_guid):
    &#34;&#34;&#34;
    Return object of worker to whose belong card or None if to no one in database
    :param card_guid: GUID of RFID card
    :return: &lt;Worker&gt; instance or None
    &#34;&#34;&#34;
    for w in self.__workers_dict.values():
        if card_guid in w.cards:
            return w
    return None</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.get_registered_logs"><code class="name flex">
<span>def <span class="ident">get_registered_logs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>:return: Registered logs in database</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_registered_logs(self):
    &#34;&#34;&#34;
    :return: Registered logs in database
    &#34;&#34;&#34;
    return self.__logs_dict</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.get_terminals"><code class="name flex">
<span>def <span class="ident">get_terminals</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>:return: Registered terminals in database</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_terminals(self):
    &#34;&#34;&#34;
    :return: Registered terminals in database
    &#34;&#34;&#34;
    return self.__terminals_dict</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.get_workers"><code class="name flex">
<span>def <span class="ident">get_workers</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>:return: Workers dictionary</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_workers(self):
    &#34;&#34;&#34;
    :return: Workers dictionary
    &#34;&#34;&#34;
    return self.__workers_dict</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.is_any_terminal_registered"><code class="name flex">
<span>def <span class="ident">is_any_terminal_registered</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if in database is registered any terminal
:return: True - at least one terminal registerd in database, False - otherwise</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_any_terminal_registered(self):
    &#34;&#34;&#34;
    Check if in database is registered any terminal
    :return: True - at least one terminal registerd in database, False - otherwise
    &#34;&#34;&#34;
    return bool(self.__terminals_dict)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.register_card_usage"><code class="name flex">
<span>def <span class="ident">register_card_usage</span></span>(<span>self, card_guid, term_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Register usage of RFID card in system via writing usage log into database
:param card_guid: GUID of used RFID card
:param term_guid: GUID of used terminal
:return: Card owner GUID or None if card without assigned owner</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_card_usage(self, card_guid, term_guid):
    &#34;&#34;&#34;
    Register usage of RFID card in system via writing usage log into database
    :param card_guid: GUID of used RFID card
    :param term_guid: GUID of used terminal
    :return: Card owner GUID or None if card without assigned owner
    &#34;&#34;&#34;
    card_owner = self.get_card_owner(card_guid)
    if not self.terminal_in_database(term_guid):
        raise DataInputError(&#34;Terminal with id: &#34; + term_guid + &#34; not assigned in database&#34;)
    if card_owner is None:
        owner_guid = None
    else:
        owner_guid = card_owner.worker_guid
    self.register_log(card_guid, term_guid, owner_guid)
    return card_owner</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.register_log"><code class="name flex">
<span>def <span class="ident">register_log</span></span>(<span>self, card_guid, term_guid, worker_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Save new register log in database
:param card_guid: GUID of used RFID card
:param term_guid: GUID of used terminal
:param worker_guid: GUID of worker to whose belong card</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_log(self, card_guid, term_guid, worker_guid):
    &#34;&#34;&#34;
    Save new register log in database
    :param card_guid: GUID of used RFID card
    :param term_guid: GUID of used terminal
    :param worker_guid: GUID of worker to whose belong card
    &#34;&#34;&#34;
    time = datetime.now()
    self.__logs_dict[time.__str__()] = RegistryLog(time.__str__(), term_guid, card_guid, worker_guid)
    self.__database.write_logs(self.__logs_dict.values())</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.remove_terminal"><code class="name flex">
<span>def <span class="ident">remove_terminal</span></span>(<span>self, term_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove terminal from database
:param term_guid:
GUID of terminal to remove</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_terminal(self, term_guid):
    &#34;&#34;&#34;
    Remove terminal from database
    :param term_guid:  GUID of terminal to remove
    &#34;&#34;&#34;
    if term_guid in self.__terminals_dict:
        del self.__terminals_dict[term_guid]
        self.__database.write_terminals(self.__terminals_dict.values())
    else:
        raise DataInputError(&#34;Terminal with GUID: &#34; + term_guid + &#34; not exist&#34;)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.remove_worker"><code class="name flex">
<span>def <span class="ident">remove_worker</span></span>(<span>self, worker_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove worker from database
:param worker_guid: GUID of worker to remove</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_worker(self, worker_guid):
    &#34;&#34;&#34;
    Remove worker from database
    :param worker_guid: GUID of worker to remove
    &#34;&#34;&#34;
    if worker_guid in self.__workers_dict:
        del self.__workers_dict[worker_guid]
        self.__database.write_workers(self.__workers_dict.values())
    else:
        raise DataInputError(&#34;Worker with GUID: &#34; + worker_guid + &#34; not exist&#34;)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.report_log_from_day"><code class="name flex">
<span>def <span class="ident">report_log_from_day</span></span>(<span>self, with_saving, date=datetime.datetime(2020, 4, 13, 16, 2, 38, 973269))</span>
</code></dt>
<dd>
<section class="desc"><p>Generate report with all logs added in given date
:param with_saving: True - save report in database, False - not save report in database
:param date: will be returned only logs with date equals <date>
:return: List of <RegistryLog> objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_log_from_day(self, with_saving, date=datetime.now()):
    &#34;&#34;&#34;
    Generate report with all logs added in given date
    :param with_saving: True - save report in database, False - not save report in database
    :param date: will be returned only logs with date equals &lt;date&gt;
    :return: List of &lt;RegistryLog&gt; objects
    &#34;&#34;&#34;
    predicate = lambda k: datetime.strptime(k, &#34;%Y-%m-%d %H:%M:%S.%f&#34;).date() == date.date()
    filtered_keys = list(filter(predicate, self.__logs_dict.keys()))
    filtered_logs = list(map(lambda k: self.__logs_dict[k], filtered_keys))

    if with_saving:
        report_name = &#34;Report_[LOGS]_&#34; + date.date().__str__()
        self.__database.write_reports_with_objects(filtered_logs, report_name)
    return filtered_logs</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.report_log_from_day_worker"><code class="name flex">
<span>def <span class="ident">report_log_from_day_worker</span></span>(<span>self, worker_guid, with_saving, date=datetime.datetime(2020, 4, 13, 16, 2, 38, 973274))</span>
</code></dt>
<dd>
<section class="desc"><p>Generate report with all logs added in given date which relate with worker with given GUID
:param worker_guid: GUID of worker for whose we generate reports
:param with_saving: True - save report in database, False - not save report in database
:param date: will be returned only logs with date equals <date>
:return: List of <RegistryLog> objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_log_from_day_worker(self, worker_guid, with_saving, date=datetime.now()):
    &#34;&#34;&#34;
    Generate report with all logs added in given date which relate with worker with given GUID
    :param worker_guid: GUID of worker for whose we generate reports
    :param with_saving: True - save report in database, False - not save report in database
    :param date: will be returned only logs with date equals &lt;date&gt;
    :return: List of &lt;RegistryLog&gt; objects
    &#34;&#34;&#34;
    logs_from_day = self.report_log_from_day(False, date)
    filtered_logs = list(filter(lambda l: l.worker_guid == worker_guid, logs_from_day))

    if with_saving:
        report_name = &#34;Report_[LOGS]_[&#34; + worker_guid + &#34;]_&#34; + date.date().__str__()
        self.__database.write_reports_with_objects(filtered_logs, report_name)
    return filtered_logs</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.report_work_time_from_day"><code class="name flex">
<span>def <span class="ident">report_work_time_from_day</span></span>(<span>self, with_saving, date=datetime.datetime(2020, 4, 13, 16, 2, 38, 973277))</span>
</code></dt>
<dd>
<section class="desc"><p>Generate report with tuples (worker GUID, work time) for given day
:param with_saving: True - save report in database, False - not save report in database
:param date: will be returned only results with date equals <date>
:return: List of tuples (worker GUID, work time <datatime>)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_work_time_from_day(self, with_saving, date=datetime.now()):
    &#34;&#34;&#34;
    Generate report with tuples (worker GUID, work time) for given day
    :param with_saving: True - save report in database, False - not save report in database
    :param date: will be returned only results with date equals &lt;date&gt;
    :return: List of tuples (worker GUID, work time &lt;datatime&gt;)
    &#34;&#34;&#34;
    fun = lambda guid: (guid, self.report_work_time_from_day_worker(guid, date))
    work_time_list = list(map(fun, self.__workers_dict.keys()))
    only_positive_work_time = list(filter(lambda time: time[1] &gt; time[1].min, work_time_list))
    if with_saving:
        report_name = &#34;Report_[TIME]_&#34; + date.date().__str__()
        self.__database.write_reports_with_tuples(only_positive_work_time, report_name)
    return only_positive_work_time</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.report_work_time_from_day_worker"><code class="name flex">
<span>def <span class="ident">report_work_time_from_day_worker</span></span>(<span>self, worker_guid, date=datetime.datetime(2020, 4, 13, 16, 2, 38, 973276))</span>
</code></dt>
<dd>
<section class="desc"><p>Generate datatime value which means how much time worker with given GUID work in given day
:param worker_guid: GUID of worker for whose we generate reports
:param date: will be returned only logs with date equals <date>
:return: <datatime> value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_work_time_from_day_worker(self, worker_guid, date=datetime.now()):
    &#34;&#34;&#34;
    Generate datatime value which means how much time worker with given GUID work in given day
    :param worker_guid: GUID of worker for whose we generate reports
    :param date: will be returned only logs with date equals &lt;date&gt;
    :return: &lt;datatime&gt; value
    &#34;&#34;&#34;
    worker_log_for_day = self.report_log_from_day_worker(worker_guid, False, date)
    return self.calculate_work_time_for_worker(worker_log_for_day)</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.set_terminal_engage"><code class="name flex">
<span>def <span class="ident">set_terminal_engage</span></span>(<span>self, term_GUID, engaged)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_terminal_engage(self, term_GUID, engaged):
    if self.terminal_in_database(term_GUID):
        self.__terminals_dict[term_GUID].is_engaged = engaged</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.terminal_in_database"><code class="name flex">
<span>def <span class="ident">terminal_in_database</span></span>(<span>self, term_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if terminal with given GUID is saved in database
:param term_guid: GUID of checked terminal
:return: True - is in database, False - otherwise</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminal_in_database(self, term_guid):
    &#34;&#34;&#34;
    Check if terminal with given GUID is saved in database
    :param term_guid: GUID of checked terminal
    :return: True - is in database, False - otherwise
    &#34;&#34;&#34;
    return term_guid in self.__terminals_dict</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.terminal_is_engaged"><code class="name flex">
<span>def <span class="ident">terminal_is_engaged</span></span>(<span>self, term_GUID)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminal_is_engaged(self, term_GUID):
    if self.terminal_in_database(term_GUID):
        return self.__terminals_dict[term_GUID].is_engaged
    return False</code></pre>
</details>
</dd>
<dt id="app.logic.server.Server.unassign_card_from_worker"><code class="name flex">
<span>def <span class="ident">unassign_card_from_worker</span></span>(<span>self, card_guid)</span>
</code></dt>
<dd>
<section class="desc"><p>Unassign card which had assigned to worker
:param card_guid: GUID of RFID card which needs to be unassigned</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unassign_card_from_worker(self, card_guid):
    &#34;&#34;&#34;
    Unassign card which had assigned to worker
    :param card_guid: GUID of RFID card which needs to be unassigned
    &#34;&#34;&#34;
    for w in self.__workers_dict.values():
        if card_guid in w.cards:
            w.cards.remove(card_guid)
            self.__database.write_workers(self.__workers_dict.values())
            return w.worker_guid
    raise DataInputError(&#34;Card with id: &#34; + card_guid + &#34; hasn&#39;t been signed to any worker&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.logic" href="index.html">app.logic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.logic.server.DataInputError" href="#app.logic.server.DataInputError">DataInputError</a></code></h4>
</li>
<li>
<h4><code><a title="app.logic.server.Server" href="#app.logic.server.Server">Server</a></code></h4>
<ul class="">
<li><code><a title="app.logic.server.Server.add_terminal" href="#app.logic.server.Server.add_terminal">add_terminal</a></code></li>
<li><code><a title="app.logic.server.Server.add_worker" href="#app.logic.server.Server.add_worker">add_worker</a></code></li>
<li><code><a title="app.logic.server.Server.assign_card_to_worker" href="#app.logic.server.Server.assign_card_to_worker">assign_card_to_worker</a></code></li>
<li><code><a title="app.logic.server.Server.calculate_work_time_for_worker" href="#app.logic.server.Server.calculate_work_time_for_worker">calculate_work_time_for_worker</a></code></li>
<li><code><a title="app.logic.server.Server.general_log_for_worker" href="#app.logic.server.Server.general_log_for_worker">general_log_for_worker</a></code></li>
<li><code><a title="app.logic.server.Server.general_report" href="#app.logic.server.Server.general_report">general_report</a></code></li>
<li><code><a title="app.logic.server.Server.get_card_owner" href="#app.logic.server.Server.get_card_owner">get_card_owner</a></code></li>
<li><code><a title="app.logic.server.Server.get_registered_logs" href="#app.logic.server.Server.get_registered_logs">get_registered_logs</a></code></li>
<li><code><a title="app.logic.server.Server.get_terminals" href="#app.logic.server.Server.get_terminals">get_terminals</a></code></li>
<li><code><a title="app.logic.server.Server.get_workers" href="#app.logic.server.Server.get_workers">get_workers</a></code></li>
<li><code><a title="app.logic.server.Server.is_any_terminal_registered" href="#app.logic.server.Server.is_any_terminal_registered">is_any_terminal_registered</a></code></li>
<li><code><a title="app.logic.server.Server.register_card_usage" href="#app.logic.server.Server.register_card_usage">register_card_usage</a></code></li>
<li><code><a title="app.logic.server.Server.register_log" href="#app.logic.server.Server.register_log">register_log</a></code></li>
<li><code><a title="app.logic.server.Server.remove_terminal" href="#app.logic.server.Server.remove_terminal">remove_terminal</a></code></li>
<li><code><a title="app.logic.server.Server.remove_worker" href="#app.logic.server.Server.remove_worker">remove_worker</a></code></li>
<li><code><a title="app.logic.server.Server.report_log_from_day" href="#app.logic.server.Server.report_log_from_day">report_log_from_day</a></code></li>
<li><code><a title="app.logic.server.Server.report_log_from_day_worker" href="#app.logic.server.Server.report_log_from_day_worker">report_log_from_day_worker</a></code></li>
<li><code><a title="app.logic.server.Server.report_work_time_from_day" href="#app.logic.server.Server.report_work_time_from_day">report_work_time_from_day</a></code></li>
<li><code><a title="app.logic.server.Server.report_work_time_from_day_worker" href="#app.logic.server.Server.report_work_time_from_day_worker">report_work_time_from_day_worker</a></code></li>
<li><code><a title="app.logic.server.Server.set_terminal_engage" href="#app.logic.server.Server.set_terminal_engage">set_terminal_engage</a></code></li>
<li><code><a title="app.logic.server.Server.terminal_in_database" href="#app.logic.server.Server.terminal_in_database">terminal_in_database</a></code></li>
<li><code><a title="app.logic.server.Server.terminal_is_engaged" href="#app.logic.server.Server.terminal_is_engaged">terminal_is_engaged</a></code></li>
<li><code><a title="app.logic.server.Server.unassign_card_from_worker" href="#app.logic.server.Server.unassign_card_from_worker">unassign_card_from_worker</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>